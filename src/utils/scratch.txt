
//


Black: \u001b[30m
Red: \u001b[31m
Green: \u001b[32m
Yellow: \u001b[33m
Blue: \u001b[34m
Magenta: \u001b[35m
Cyan: \u001b[36m
White: \u001b[37m
Reset: \u001b[0m

Bright Black: \u001b[30;1m
Bright Red: \u001b[31;1m
Bright Green: \u001b[32;1m
Bright Yellow: \u001b[33;1m
Bright Blue: \u001b[34;1m
Bright Magenta: \u001b[35;1m
Bright Cyan: \u001b[36;1m
Bright White: \u001b[37;1m
Reset: \u001b[0m



Background Black: \u001b[40m
Background Red: \u001b[41m
Background Green: \u001b[42m
Background Yellow: \u001b[43m
Background Blue: \u001b[44m
Background Magenta: \u001b[45m
Background Cyan: \u001b[46m
Background White: \u001b[47m

Background Bright Black: \u001b[40;1m
Background Bright Red: \u001b[41;1m
Background Bright Green: \u001b[42;1m
Background Bright Yellow: \u001b[43;1m
Background Bright Blue: \u001b[44;1m
Background Bright Magenta: \u001b[45;1m
Background Bright Cyan: \u001b[46;1m
Background Bright White: \u001b[47;1m

Reset: \u001b[0m


Bold: \u001b[1m
Underline: \u001b[4m
Reversed: \u001b[7m

Up: \u001b[{n}A
Down: \u001b[{n}B
Right: \u001b[{n}C
Left: \u001b[{n}D

Next Line: \u001b[{n}E moves cursor to beginning of line n lines down
Prev Line: \u001b[{n}F moves cursor to beginning of line n lines down

Set Column: \u001b[{n}G moves cursor to column n
Set Position: \u001b[{n};{m}H moves cursor to row n column m

Clear Screen: \u001b[{n}J clears the screen
    n=0 clears from cursor until end of screen,
    n=1 clears from cursor to beginning of screen
    n=2 clears entire screen

Clear Line: \u001b[{n}K clears the current line
    n=0 clears from cursor to end of line
    n=1 clears from cursor to start of line
    n=2 clears entire line

Save Position: \u001b[{s} saves the current cursor position
Save Position: \u001b[{u} restores the cursor to the last saved position


\u001b[?25l	make cursor invisible
\u001b[?25h	make cursor visible
\u001b[?47l	restore screen
\u001b[?47h	save screen
\u001b[?1049h	enables the alternative buffer
\u001b[?1049l	disables the alternative buffer

















// Define Slice as a range adaptor closure
struct slice : std::ranges::range_adaptor_closure<slice>
{
	std::size_t start = 0;
	std::size_t end   = std::string_view::npos;

	constexpr slice(size_t s, size_t e)
		: start(s)
		, end(e)
	{
	}

	constexpr std::string_view operator()(std::string_view sv) const { return sv.substr(start, end - start); }
};

	constexpr std::string_view str = "01234567";

	//	constexpr slice slicer{.start = 1, .end = 6};
	constexpr slice slicer(1, 6);

	constexpr auto sv1 = slicer(str);       // use slicer as a normal function object
	constexpr auto sv2 = str | slice{1, 6}; // use slicer as a range adaptor closure object
	static_assert(sv1 == "12345");
	static_assert(sv2 == "12345");

///////////////////////////////////

 Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

Monkey 2:
  Starting items: 79, 60, 97
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 1
    If false: throw to monkey 3

Monkey 3:
  Starting items: 74
  Operation: new = old + 3
  Test: divisible by 17
    If true: throw to monkey 0
    If false: throw to monkey 1

	auto monkeys = read_lines_exact("input\\day1test.txt", "\n\n");


	u64 lcm{1};
	for (const auto &monkey : monkeys)
	{
		auto group        = split(monkey);
		i64  id           = split<i64, 1>(group[0], ": ", ignore::alphabet);
		auto items        = split<std::deque<i64>>(group[1], ",:", ignore::alphabet | ignore::whitespace);
		auto [op, value]  = split_optional<char, i64>(group[2], " ", 4, 5);
		i64 test          = split<i64, 1>(group[3], ": ", ignore::alphabet);
		lcm               = std::lcm(lcm, test);
		auto true_monkey  = split<i64, 1>(group[4], ": ", ignore::alphabet);
		auto false_monkey = split<i64, 1>(group[5], ": ", ignore::alphabet);

		int x = 0;
	}

    //////////////////////////////////////////////////////////






	template<typename T = i64>
	using undirected_graph = std::unordered_map<T, std::unordered_set<T>>;


	 std::unordered_map<std::string, std::unordered_set<std::string>> edges;

    for (const auto &line : read_lines("input\\day12.txt"))
    {
        auto [from, to] = split_two(line, "-");
        edges[from].insert(to);
        edges[to].insert(from);

        // Directed: from->to
	}



	
i64 visit_cave(const std::string &key, const auto &edges, auto &visited, bool twice, i64 count = 0) noexcept
{
    if (key == "end")
        return 1;

    for (const std::string &next : edges.at(key))
    {
        if (!visited.contains(next))
        {
            if (std::islower(next[0]))
                visited.insert(next);

            count += visit_cave(next, edges, visited, twice);

            if (std::islower(next[0]))
                visited.erase(next);
        }
        else if (twice && next != "start")
            count += visit_cave(next, edges, visited, false);
    }
    return count;
}

i64 visit_cave(const auto &edges, bool twice) noexcept
{
    std::unordered_set<std::string> visited{"start"};
    return visit_cave("start", edges, visited, twice);
}




// DFS

// DFS algorithm
void Graph::DFS(int vertex) {
  visited[vertex] = true;
  list<int> adjList = adjLists[vertex];

  cout << vertex << " ";

  list<int>::iterator i;
  for (i = adjList.begin(); i != adjList.end(); ++i)
    if (!visited[*i])
      DFS(*i);
}
int main() {
  Graph g(4);
  g.addEdge(0, 1);
  g.addEdge(0, 2);
  g.addEdge(1, 2);
  g.addEdge(2, 3);

  g.DFS(2);

  return 0;
}




void Graph::DFS(int s){
// Initially mark all vertices as not visited
vector<bool> visited(V, false);
// Create a stack for DFS
stack<int> stack;
// Push the current source node.
stack.push(s);
while (!stack.empty()){
// Pop a vertex from stack and print it
    int s = stack.top();
    stack.pop();
    // Stack may contain same vertex twice. So
    // we need to print the popped item only
    // if it is not visited.
    if (!visited[s]){
    cout << s << " ";
    visited[s] = true;
    }
    // Get all adjacent vertices of the popped vertex s
    // If a adjacent has not been visited, then push it
    // to the stack.
    for (auto i = adj[s].begin(); i != adj[s].end(); ++i)
        if (!visited[*i]) 
            stack.push(*i);
}
}


// BFS

void Graph::BFS(int s)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for(int i = 0; i < V; i++)
        visited[i] = false;

    // Create a queue for BFS
    list<int> queue;

    // Mark the current node as visited and enqueue it
    visited[s] = true;
    queue.push_back(s);

    // 'i' will be used to get all adjacent
    // vertices of a vertex
    list<int>::iterator i;

    while(!queue.empty())
    {
        // Dequeue a vertex from queue and print it
        s = queue.front();
        cout << s << " ";
        queue.pop_front();

        // Get all adjacent vertices of the dequeued
        // vertex s. If a adjacent has not been visited, 
        // then mark it visited and enqueue it
        for (i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if (!visited[*i])
            {
                visited[*i] = true;
                queue.push_back(*i);
            }
        }
    }
}

///////////////////////////////////







 	for (const auto &column : std::views::iota(32, 64))
	{
		for (const auto &row : std::views::iota(0, 96) | std::views::stride(32))
		{
			int num = column + row;
			dbg("{0:>03d} {0:#04x} {1:2c} ", num, num > 32 && num < 128 ? num : ' ');
		}
		dbgln();
	}

 
 32 0x20     64 0x40 @    96 0x60 `  
 33 0x21 !   65 0x41 A    97 0x61 a  
 34 0x22 "   66 0x42 B    98 0x62 b  
 35 0x23 #   67 0x43 C    99 0x63 c  
 36 0x24 $   68 0x44 D   100 0x64 d  
 37 0x25 %   69 0x45 E   101 0x65 e  
 38 0x26 &   70 0x46 F   102 0x66 f  
 39 0x27 '   71 0x47 G   103 0x67 g  
 40 0x28 (   72 0x48 H   104 0x68 h  
 41 0x29 )   73 0x49 I   105 0x69 i  
 42 0x2a *   74 0x4a J   106 0x6a j  
 43 0x2b +   75 0x4b K   107 0x6b k  
 44 0x2c ,   76 0x4c L   108 0x6c l  
 45 0x2d -   77 0x4d M   109 0x6d m  
 46 0x2e .   78 0x4e N   110 0x6e n  
 47 0x2f /   79 0x4f O   111 0x6f o  
 48 0x30 0   80 0x50 P   112 0x70 p  
 49 0x31 1   81 0x51 Q   113 0x71 q  
 50 0x32 2   82 0x52 R   114 0x72 r  
 51 0x33 3   83 0x53 S   115 0x73 s  
 52 0x34 4   84 0x54 T   116 0x74 t  
 53 0x35 5   85 0x55 U   117 0x75 u  
 54 0x36 6   86 0x56 V   118 0x76 v  
 55 0x37 7   87 0x57 W   119 0x77 w  
 56 0x38 8   88 0x58 X   120 0x78 x  
 57 0x39 9   89 0x59 Y   121 0x79 y  
 58 0x3a :   90 0x5a Z   122 0x7a z  
 59 0x3b ;   91 0x5b [   123 0x7b {  
 60 0x3c <   92 0x5c \   124 0x7c |  
 61 0x3d =   93 0x5d ]   125 0x7d }  
 62 0x3e >   94 0x5e ^   126 0x7e ~  
 63 0x3f ?   95 0x5f _   127 0x7f   



		
		
		
		std::string t{"-One-Two-Three-Four-Five-Six-"};
		const auto  dash      = [](char x, char y) { return not(x == '-' or y == '-'); };
		const auto  dash3     = [](char x) { return x == '-'; };
		const auto  not_empty = [](auto x) { return not x.empty(); };


		auto words = t | std::views::lazy_split('-') | std::views::filter(not_empty) | std::views::stride(2) |
					 std::ranges::to<std::vector<std::string>>();

		for (const auto& word : words)
		{
			dbgln("{}", word);
		}